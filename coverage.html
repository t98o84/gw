
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/t98o84/gw/cmd/add.go (12.5%)</option>
				
				<option value="file1">github.com/t98o84/gw/cmd/add_helpers.go (85.7%)</option>
				
				<option value="file2">github.com/t98o84/gw/cmd/exec.go (3.6%)</option>
				
				<option value="file3">github.com/t98o84/gw/cmd/fn.go (18.2%)</option>
				
				<option value="file4">github.com/t98o84/gw/cmd/fzf.go (0.0%)</option>
				
				<option value="file5">github.com/t98o84/gw/cmd/init.go (100.0%)</option>
				
				<option value="file6">github.com/t98o84/gw/cmd/ls.go (8.7%)</option>
				
				<option value="file7">github.com/t98o84/gw/cmd/rm.go (7.1%)</option>
				
				<option value="file8">github.com/t98o84/gw/cmd/root.go (25.0%)</option>
				
				<option value="file9">github.com/t98o84/gw/cmd/sw.go (7.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/t98o84/gw/internal/fzf"
        "github.com/t98o84/gw/internal/git"
        "github.com/t98o84/gw/internal/shell"
)

var (
        addCreateBranch bool
        addPRIdentifier string
)

var addCmd = &amp;cobra.Command{
        Use:     "add &lt;branch&gt;",
        Aliases: []string{"a"},
        Short:   "Create a new worktree",
        Long: `Create a new worktree for the specified branch.

The worktree will be created in a sibling directory with the naming convention:
  &lt;repo-name&gt;-&lt;branch-suffix&gt;

Examples:
  gw add feature/hoge
    Creates ../ex-repo-feature-hoge/ and checks out feature/hoge

  gw add -b feature/new
    Creates a new branch and worktree

  gw add --pr 123
    Creates a worktree for PR #123

  gw add
    Interactive branch selection with fzf`,
        Args: cobra.MaximumNArgs(1),
        RunE: runAdd,
}

func init() <span class="cov8" title="1">{
        addCmd.Flags().BoolVarP(&amp;addCreateBranch, "branch", "b", false, "Create a new branch")
        addCmd.Flags().StringVar(&amp;addPRIdentifier, "pr", "", "PR number or URL to create worktree for")
        rootCmd.AddCommand(addCmd)
}</span>

func runAdd(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        selector := fzf.NewSelector(shell.NewRealExecutor())
        return runAddWithSelector(cmd, args, selector)
}</span>

func runAddWithSelector(cmd *cobra.Command, args []string, selector fzf.Selector) error <span class="cov0" title="0">{
        repoName, err := git.GetRepoName()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get repository name: %w", err)
        }</span>

        // Create options
        <span class="cov0" title="0">opts := &amp;addOptions{
                createBranch: addCreateBranch,
                prIdentifier: addPRIdentifier,
                selector:     selector,
        }

        // Determine branch
        branch, err := determineBranch(args, opts, repoName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if branch == "" </span><span class="cov0" title="0">{
                return nil // User cancelled
        }</span>

        // Check if worktree already exists
        <span class="cov0" title="0">existing, err := checkExistingWorktree(branch)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                fmt.Printf("Worktree already exists: %s\n", existing.Path)
                return nil
        }</span>

        // Ensure branch exists or can be created
        <span class="cov0" title="0">fromPR := opts.prIdentifier != ""
        if err := ensureBranchExists(branch, addCreateBranch, fromPR); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create the worktree
        <span class="cov0" title="0">return createWorktree(repoName, branch, addCreateBranch)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"

        "github.com/t98o84/gw/internal/fzf"
        "github.com/t98o84/gw/internal/git"
        "github.com/t98o84/gw/internal/github"
)

// addOptions contains options for worktree creation
type addOptions struct {
        createBranch bool
        prIdentifier string
        selector     fzf.Selector
}

// determineBranch determines which branch to use based on args and options
func determineBranch(args []string, opts *addOptions, repoName string) (string, error) <span class="cov8" title="1">{
        // Handle PR flag
        if opts.prIdentifier != "" </span><span class="cov8" title="1">{
                branch, err := getBranchFromPR(opts.prIdentifier, repoName)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return branch, nil</span>
        }

        // Interactive selection if no args
        <span class="cov8" title="1">if len(args) == 0 </span><span class="cov8" title="1">{
                branch, err := selectBranchInteractive(opts.selector)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return branch, nil</span>
        }

        // Use provided branch name
        <span class="cov8" title="1">return args[0], nil</span>
}

// getBranchFromPR retrieves branch name from PR identifier
func getBranchFromPR(prIdentifier, repoName string) (string, error) <span class="cov8" title="1">{
        if mockGetPRBranch != nil </span><span class="cov8" title="1">{
                return mockGetPRBranch(prIdentifier, repoName)
        }</span>
        <span class="cov0" title="0">branch, err := github.GetPRBranch(prIdentifier, repoName)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get PR branch: %w", err)
        }</span>
        <span class="cov0" title="0">return branch, nil</span>
}

// selectBranchInteractive shows interactive branch selector
func selectBranchInteractive(selector fzf.Selector) (string, error) <span class="cov8" title="1">{
        var branches []string
        var err error
        if mockListBranches != nil </span><span class="cov8" title="1">{
                branches, err = mockListBranches()
        }</span> else<span class="cov0" title="0"> {
                branches, err = git.ListBranches()
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to list branches: %w", err)
        }</span>

        <span class="cov8" title="1">branch, err := selector.SelectBranch(branches)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return branch, nil</span>
}

// checkExistingWorktree checks if worktree already exists for the branch
func checkExistingWorktree(branch string) (*git.Worktree, error) <span class="cov8" title="1">{
        var existing *git.Worktree
        var err error
        if mockFindWorktree != nil </span><span class="cov8" title="1">{
                existing, err = mockFindWorktree(branch)
        }</span> else<span class="cov0" title="0"> {
                existing, err = git.FindWorktree(branch)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to check existing worktree: %w", err)
        }</span>
        <span class="cov8" title="1">return existing, nil</span>
}

// ensureBranchExists checks and fetches branch if necessary
func ensureBranchExists(branch string, createBranch bool, fromPR bool) error <span class="cov8" title="1">{
        // If creating a new branch (and not from PR), it will be created with worktree
        if createBranch &amp;&amp; !fromPR </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check if branch exists locally
        <span class="cov8" title="1">var exists bool
        var err error
        if mockBranchExists != nil </span><span class="cov8" title="1">{
                exists, err = mockBranchExists(branch)
        }</span> else<span class="cov0" title="0"> {
                exists, err = git.BranchExists(branch)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to check branch: %w", err)
        }</span>

        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                // Try to fetch from remote
                var remoteExists bool
                if mockRemoteBranchExists != nil </span><span class="cov8" title="1">{
                        remoteExists, err = mockRemoteBranchExists(branch)
                }</span> else<span class="cov0" title="0"> {
                        remoteExists, err = git.RemoteBranchExists(branch)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to check remote branch: %w", err)
                }</span>

                <span class="cov8" title="1">if remoteExists </span><span class="cov8" title="1">{
                        fmt.Printf("Fetching branch %s from origin...\n", branch)
                        if mockFetchBranch != nil </span><span class="cov8" title="1">{
                                err = mockFetchBranch(branch)
                        }</span> else<span class="cov0" title="0"> {
                                err = git.FetchBranch(branch)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to fetch branch: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if !createBranch </span><span class="cov8" title="1">{
                        return fmt.Errorf("branch %s does not exist (use -b to create)", branch)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createWorktree creates a new worktree for the given branch
func createWorktree(repoName, branch string, createBranch bool) error <span class="cov8" title="1">{
        var wtPath string
        var err error
        if mockWorktreePath != nil </span><span class="cov8" title="1">{
                wtPath, err = mockWorktreePath(repoName, branch)
        }</span> else<span class="cov0" title="0"> {
                wtPath, err = git.WorktreePath(repoName, branch)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to generate worktree path: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Creating worktree at %s for branch %s...\n", wtPath, branch)
        if mockAdd != nil </span><span class="cov8" title="1">{
                err = mockAdd(wtPath, branch, createBranch)
        }</span> else<span class="cov0" title="0"> {
                err = git.Add(wtPath, branch, createBranch)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Printf("✓ Worktree created: %s\n", wtPath)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "os"
        "os/exec"

        "github.com/spf13/cobra"
        "github.com/t98o84/gw/internal/git"
)

var execCmd = &amp;cobra.Command{
        Use:     "exec &lt;name&gt; &lt;command...&gt;",
        Aliases: []string{"e"},
        Short:   "Execute a command in a worktree",
        Long: `Execute a command in the specified worktree directory.

The current directory is preserved after command execution.

Examples:
  gw exec feature/hoge git status
  gw exec feature-hoge npm install
  gw exec ex-repo-feature-hoge make build
  gw exec git status
    Interactive worktree selection with fzf, then run 'git status'`,
        Args: cobra.MinimumNArgs(1),
        RunE: runExec,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(execCmd)
}</span>

func runExec(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        var wt *git.Worktree
        var command []string
        var err error

        // Try to find the first arg as a worktree
        if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                wt, err = git.FindWorktree(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find worktree: %w", err)
                }</span>
                <span class="cov0" title="0">if wt != nil </span><span class="cov0" title="0">{
                        command = args[1:]
                }</span> else<span class="cov0" title="0"> {
                        // First arg is not a worktree, treat all args as command
                        command = args
                }</span>
        } else<span class="cov0" title="0"> {
                // Only command provided, no worktree specified
                command = args
        }</span>

        // If no worktree found, use fzf to select
        <span class="cov0" title="0">if wt == nil </span><span class="cov0" title="0">{
                wt, err = selectWorktreeWithFzf(false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if wt == nil </span><span class="cov0" title="0">{
                        return nil // User cancelled
                }</span>
        }

        // Execute command in the worktree directory
        <span class="cov0" title="0">execCommand := exec.Command(command[0], command[1:]...)
        execCommand.Dir = wt.Path
        execCommand.Stdin = os.Stdin
        execCommand.Stdout = os.Stdout
        execCommand.Stderr = os.Stderr

        if err := execCommand.Run(); err != nil </span><span class="cov0" title="0">{
                if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        os.Exit(exitErr.ExitCode())
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to execute command: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

var fnPrintPath bool

var fnCmd = &amp;cobra.Command{
        Use:     "fn",
        Aliases: []string{"f"},
        Short:   "Find a worktree with fzf",
        Long: `Find a worktree using fzf interactive search.

Prints the selected worktree name or path.

Examples:
  gw fn           # Interactive search, print worktree name
  gw fn -p        # Interactive search, print full path`,
        Args: cobra.NoArgs,
        RunE: runFn,
}

func init() <span class="cov8" title="1">{
        fnCmd.Flags().BoolVarP(&amp;fnPrintPath, "path", "p", false, "Print the full path instead of directory name")
        rootCmd.AddCommand(fnCmd)
}</span>

func runFn(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        wt, err := selectWorktreeWithFzf(false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if wt == nil </span><span class="cov0" title="0">{
                return nil // User cancelled
        }</span>

        <span class="cov0" title="0">if fnPrintPath </span><span class="cov0" title="0">{
                fmt.Println(wt.Path)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(wt.Branch)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "github.com/t98o84/gw/internal/fzf"
        "github.com/t98o84/gw/internal/git"
        "github.com/t98o84/gw/internal/shell"
)

// selectWorktreeWithFzf shows an interactive worktree selector using fzf
// excludeMain: if true, excludes the main worktree from the list
func selectWorktreeWithFzf(excludeMain bool) (*git.Worktree, error) <span class="cov0" title="0">{
        selector := fzf.NewSelector(shell.NewRealExecutor())
        return selectWorktreeWithSelector(selector, excludeMain)
}</span>

func selectWorktreeWithSelector(selector fzf.Selector, excludeMain bool) (*git.Worktree, error) <span class="cov0" title="0">{
        worktrees, err := git.List()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return selector.SelectWorktree(worktrees, excludeMain)</span>
}

// selectWorktreesWithFzf shows an interactive worktree selector using fzf with multi-select support
// excludeMain: if true, excludes the main worktree from the list
// multi: if true, allows selecting multiple worktrees (use Tab to select)
func selectWorktreesWithFzf(excludeMain bool, multi bool) ([]*git.Worktree, error) <span class="cov0" title="0">{
        selector := fzf.NewSelector(shell.NewRealExecutor())
        return selectWorktreesWithSelector(selector, excludeMain, multi)
}</span>

func selectWorktreesWithSelector(selector fzf.Selector, excludeMain bool, multi bool) ([]*git.Worktree, error) <span class="cov0" title="0">{
        worktrees, err := git.List()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return selector.SelectWorktrees(worktrees, excludeMain, multi)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

var initCmd = &amp;cobra.Command{
        Use:     "init &lt;shell&gt;",
        Aliases: []string{"i"},
        Short:   "Print shell initialization script",
        Long: `Print shell initialization script for directory switching support.

Supported shells: bash, zsh, fish

Add to your shell configuration:
  bash: eval "$(gw init bash)"   # Add to ~/.bashrc
  zsh:  eval "$(gw init zsh)"    # Add to ~/.zshrc
  fish: gw init fish | source    # Add to ~/.config/fish/config.fish`,
        Args:      cobra.ExactArgs(1),
        ValidArgs: []string{"bash", "zsh", "fish"},
        RunE:      runInit,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(initCmd)
}</span>

func runInit(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        shell := args[0]

        switch shell </span>{
        case "bash", "zsh":<span class="cov8" title="1">
                fmt.Print(bashZshInit)</span>
        case "fish":<span class="cov8" title="1">
                fmt.Print(fishInit)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unsupported shell: %s (supported: bash, zsh, fish)", shell)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

const bashZshInit = `# gw shell integration
gw() {
  if [ "$1" = "sw" ] || [ "$1" = "s" ]; then
    local target
    target="$(command gw sw --print-path "${@:2}")"
    if [ -n "$target" ]; then
      cd "$target"
    fi
  else
    command gw "$@"
  fi
}
`

const fishInit = `# gw shell integration
function gw
  if test "$argv[1]" = "sw" -o "$argv[1]" = "s"
    set -l target (command gw sw --print-path $argv[2..])
    if test -n "$target"
      cd $target
    end
  else
    command gw $argv
  end
end
`
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "fmt"
        "path/filepath"

        "github.com/spf13/cobra"
        "github.com/t98o84/gw/internal/git"
)

var lsPrintPath bool

var lsCmd = &amp;cobra.Command{
        Use:     "ls",
        Aliases: []string{"l"},
        Short:   "List all worktrees",
        Long: `List all worktrees for the current repository.

Shows the directory name for each worktree.`,
        RunE: runLs,
}

func init() <span class="cov8" title="1">{
        lsCmd.Flags().BoolVarP(&amp;lsPrintPath, "path", "p", false, "Print the full path instead of directory name")
        rootCmd.AddCommand(lsCmd)
}</span>

func runLs(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        worktrees, err := git.List()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list worktrees: %w", err)
        }</span>

        <span class="cov0" title="0">if len(worktrees) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No worktrees found")
                return nil
        }</span>

        <span class="cov0" title="0">for _, wt := range worktrees </span><span class="cov0" title="0">{
                var name string
                if lsPrintPath </span><span class="cov0" title="0">{
                        name = wt.Path
                }</span> else<span class="cov0" title="0"> {
                        name = filepath.Base(wt.Path)
                }</span>

                // Get short commit hash (first 7 characters)
                <span class="cov0" title="0">shortCommit := wt.Commit
                if len(shortCommit) &gt; 7 </span><span class="cov0" title="0">{
                        shortCommit = shortCommit[:7]
                }</span>

                // Format: name branch commit (main)
                <span class="cov0" title="0">branch := wt.Branch
                if branch == "" </span><span class="cov0" title="0">{
                        branch = "(detached)"
                }</span>

                <span class="cov0" title="0">if wt.IsMain </span><span class="cov0" title="0">{
                        fmt.Printf("%s %s %s (main)\n", name, branch, shortCommit)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%s %s %s\n", name, branch, shortCommit)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/t98o84/gw/internal/git"
)

var rmForce bool

var rmCmd = &amp;cobra.Command{
        Use:     "rm [name...]",
        Aliases: []string{"r"},
        Short:   "Remove worktrees",
        Long: `Remove one or more worktrees by name.

The name can be specified in various formats:
  - Branch name: feature/hoge
  - Suffix: feature-hoge
  - Full directory name: ex-repo-feature-hoge

Examples:
  gw rm feature/hoge
  gw rm feature/hoge feature/fuga   # Remove multiple worktrees
  gw rm feature-hoge
  gw rm ex-repo-feature-hoge
  gw rm
    Interactive worktree selection with fzf (Tab to multi-select)`,
        RunE: runRm,
}

func init() <span class="cov8" title="1">{
        rmCmd.Flags().BoolVarP(&amp;rmForce, "force", "f", false, "Force removal even if worktree is dirty")
        rootCmd.AddCommand(rmCmd)
}</span>

func runRm(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        var worktrees []*git.Worktree

        if len(args) == 0 </span><span class="cov0" title="0">{
                // Interactive selection with fzf (exclude main worktree, multi-select enabled)
                selected, err := selectWorktreesWithFzf(true, true)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(selected) == 0 </span><span class="cov0" title="0">{
                        return nil // User cancelled
                }</span>
                <span class="cov0" title="0">worktrees = selected</span>
        } else<span class="cov0" title="0"> {
                // Find all specified worktrees
                for _, identifier := range args </span><span class="cov0" title="0">{
                        wt, err := git.FindWorktree(identifier)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to find worktree: %w", err)
                        }</span>
                        <span class="cov0" title="0">if wt == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("worktree not found: %s", identifier)
                        }</span>
                        <span class="cov0" title="0">if wt.IsMain </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot remove the main worktree: %s", identifier)
                        }</span>
                        <span class="cov0" title="0">worktrees = append(worktrees, wt)</span>
                }
        }

        // Remove all selected worktrees
        <span class="cov0" title="0">for _, wt := range worktrees </span><span class="cov0" title="0">{
                if wt.IsMain </span><span class="cov0" title="0">{
                        fmt.Printf("⚠ Skipping main worktree: %s\n", wt.Path)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("Removing worktree: %s\n", wt.Path)
                if err := git.Remove(wt.Path, rmForce); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove %s: %w", wt.Path, err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("✓ Worktree removed: %s\n", wt.Path)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

var version = "dev"

var rootCmd = &amp;cobra.Command{
        Use:   "gw",
        Short: "Git worktree wrapper - simplify git worktree management",
        Long: `gw is a CLI tool that simplifies git worktree management.

It provides easy commands to create, list, remove, and switch between worktrees
with intuitive naming conventions and fzf integration.`,
        Version: version,
}

func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.CompletionOptions.DisableDefaultCmd = true
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/t98o84/gw/internal/git"
)

var swPrintPath bool

var swCmd = &amp;cobra.Command{
        Use:     "sw [name]",
        Aliases: []string{"s"},
        Short:   "Switch to a worktree directory",
        Long: `Switch to a worktree directory.

If no name is specified and fzf is available, an interactive selector will be shown.

Note: This command requires shell integration. Run 'gw init &lt;shell&gt;' to set up.

Examples:
  gw sw feature/hoge
  gw sw feature-hoge
  gw sw              # Interactive selection with fzf`,
        Args: cobra.MaximumNArgs(1),
        RunE: runSw,
}

func init() <span class="cov8" title="1">{
        swCmd.Flags().BoolVar(&amp;swPrintPath, "print-path", false, "Print the path instead of changing directory (used by shell wrapper)")
        rootCmd.AddCommand(swCmd)
}</span>

func runSw(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        var wt *git.Worktree
        var err error

        if len(args) == 0 </span><span class="cov0" title="0">{
                // Interactive selection with fzf
                wt, err = selectWorktreeWithFzf(false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if wt == nil </span><span class="cov0" title="0">{
                        return nil // User cancelled
                }</span>
        } else<span class="cov0" title="0"> {
                identifier := args[0]

                // Find the worktree
                wt, err = git.FindWorktree(identifier)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find worktree: %w", err)
                }</span>
                <span class="cov0" title="0">if wt == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("worktree not found: %s", identifier)
                }</span>
        }

        <span class="cov0" title="0">if swPrintPath </span><span class="cov0" title="0">{
                // Just print the path for shell wrapper to use
                fmt.Println(wt.Path)
                return nil
        }</span>

        // Without shell integration, we can't actually change directory
        // Print instructions
        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "To switch to %s, run:\n", wt.Path)
        fmt.Fprintf(os.Stderr, "  cd %s\n\n", wt.Path)
        fmt.Fprintf(os.Stderr, "For automatic directory switching, set up shell integration:\n")
        fmt.Fprintf(os.Stderr, "  eval \"$(gw init bash)\"   # for bash\n")
        fmt.Fprintf(os.Stderr, "  eval \"$(gw init zsh)\"    # for zsh\n")
        fmt.Fprintf(os.Stderr, "  gw init fish | source    # for fish\n")

        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
